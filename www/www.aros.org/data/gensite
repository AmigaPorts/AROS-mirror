#!/usr/bin/env python

'''Generate the AROS WWW site.'''

import glob, os, os.path, sys

# Fix nameclash between Image and HTMLgen.Image
try: #Following switcheroo ensures that if PIL is installed it's used instead
    # of the HTMLgen-bundled copies.
    import Image
    _Image = Image
    del Image
except ImportError:
    import ImageH
    _Image = ImageH
    del ImageH
import GifImagePluginH, JpegImagePluginH, PngImagePluginH

# Import HTML generator
from HTMLcolors import *
from HTMLgen import *

_varprog = None

# Copy of os.path.expandvars
def expandvars (path, dict=os.environ):
    """Expand shell variables of form $var and ${var}.  Unknown variables
are left unchanged"""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while 1:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name[:1] == '{' and name[-1:] == '}':
            name = name[1:-1]
        if dict.has_key(name):
            tail = path[j:]
            path = path[:i] + dict[name]
            i = len(path)
            path = path + tail
        else:
            i = j
    return path

# Import global config (mostly paths)
import config

def expandpath (path):
    return os.path.expanduser (expandvars (expandvars (path, config.__dict__)))

# Copy the "interesting" items of the config into local variables.
htmldir = expandpath (config.HTMLDIR)
ftpdir = expandpath (config.FTPDIR)
convert = config.__dict__.get ('CONVERT', None)

# Allow to read in python modules from AROS
path = expandpath (os.path.join (config.AROSDIR, 'docs', 'src'))
sys.path.append (path)

# The relative URL for the screenshots dir.
screenshoturl = 'pics/screenshots'

# This is a list of links which is used to generate the linkbox
# at the beginning of every page. The format is as follows:
#
#  ( 
#    ( main-page, sub-page-1, sub-page-2, ... ),
#    ( next-main-page, ... ),
#    ( ... ),
#  )
#
# All items in the lists must be objects of the class Href.
#
# Whenever a page is generated, you must pass the title of the main
# page (second parameter to Href()) to Page() in the parameter
# linkBoxItem. This will then "open" this item (ie. the subitems
# will be shown).
# FIXME Most pages are much bigger then the link box, therefore, we
# could always open all items. That would allow the user to navigate
# much more quickly.
mainLinks = (
    ( Href ('index.html', 'NEWS'),
	Href ('status.html', 'Status'),
	Href ('credits.html', 'Credits'),
	Href ('oldnews.html', 'Old News'),
    ),
    ( Href ('documentation.html', 'Documentation'),
	Href ('autodocs/index.html', 'AutoDocs'),
    ),
    ( Href ('screenshots.html', 'Screenshots'),
	Href ('screenshots.html#Pictures around AROS', 'Pictures'),
	Href ('screenshots.html#Screenshots', 'Screenshots'),
    ),
    ( Href ('download.html', 'Download'),
	Href ('ftp://ftp.aros.org/pub/aros/', 'FTP Server'),
	Href ('snapshots.html', 'Snapshots'),
    ),
    ( Href ('links.html', 'Links'),
	Href ('links.html#More Related', 'More Related'),
	Href ('links.html#Articles', 'Articles'),
	Href ('links.html#Homepages', 'Homepages'),
	Href ('links.html#Less Related', 'Less Related'),
    ),
)

class Page (SeriesDocument):
    def __init__ (self, rcFile='aros.rc', linkBoxItem='', **kw):
	'''Base class to generate a page. linkBoxItem must be the
	Title of the main page in the linkbox (see the list mainLinks
	above).

	The "meat" of the page goes into self.meat. To add something
	to the page, use this code:

	    page = Page (...)
	    page.meat = page.meat + [item]
	
	Note that you must add a list (not a tuple or a single element)
	to page.meat.
	'''
	apply (SeriesDocument.__init__, (self, rcFile,), kw)

	# Create the header of every page.
	table = TableLite ()
	self.banner = table
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	logo = Href ('/', Image (('pics/logo.gif', 300, 123), alt='AROS'))
	td = td + [logo]
	row = row + [td, TD (Text ('Amiga Research OS'))]

	# Create another table for the page content. 
	table = TableLite ()
	self.append (table)
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	row = row + [td,]
	table2 = TableLite ()
	td = td + [table2,]
	row2 = TR ()
	table2.append (row2)
	td2 = TD (bgcolor='#40FF80', valign='TOP')
	row2 = row2 + [td2]
	self.linkbox = Font (size='-2')
	td2 = td2 + [self.linkbox]

	# The content will go here
	self.meat = TD (valign='TOP')
	row = row + [self.meat]

	# Link to the main page
	self.gohome = '/'

	if linkBoxItem:
	    list = []
	    for links in mainLinks:
		if links[0].text == linkBoxItem:
		    list.append (links)
		else:
		    list.append ((links[0],))

	    for links in list:
		self.linkbox = self.linkbox + [links[0], BR ()]
		for link in links[1:]:
		    self.linkbox = self.linkbox + [
			RawText ('&nbsp;&nbsp;&nbsp;'),
			link, BR ()]

    def relurl (self, path1, path2):
	#print self.relurl, path1, path2
	if not path2:
	    return None
	
	if string.find (path2, '://'):
	    return path2
	
	if path1[0] == '/':
	    path1 = os.path.join (htmldir, path1[1:])
	if path2[0] == '/':
	    path2 = os.path.join (htmldir, path2[1:])

	return relpath (path1, path2)

    def write (self, filename):
	filepath = os.path.join (htmldir, filename)

	# Create relative paths to other pages
	for links in mainLinks:
	    prev = next = top = None
	    for i in range (len (links)):
		url = links[i].url
		pos = string.find (url, '#')
		if pos != -1:
		    url = url[:pos]
		if url == filename:
		    if i > 0:
			prev = links[i-1].url
		    if i+1 < len (links):
			next = links[i+1].url
		    top = links[0].url
		    break
	    if top:
		break
	
	self.goprev = self.relurl (filepath, prev)
	self.gonext = self.relurl (filepath, next)
	self.gotop = self.relurl (filepath, top)

	# Convert myself into HTML
	SeriesDocument.write (self, filepath)

def genNews ():
    '''Create the news page (index.html, oldnews.html).'''

    def genPage (items, filename):
	'''Convert a list of news items into an HTML page and save
	it in filename. items must be a list of files with newsitems.
	The filenames must be dates in the form YYYYMMDD.'''

	def prepareNewsItem (filename):
	    '''Convert a single news item into HTML.'''

	    row = TR ()
	    td = TD (bgcolor='#80C0F0', valign='TOP')
	    row = row + [td]
	    str = os.path.basename (filename)
	    date = '%d.%d.%d' % (
		int (str[6:8]),
		int (str[4:6]),
		int (str[0:4]),
	    )
	    td = td + [Name (str), date]

	    td = TD (valign='TOP')
	    row = row + [td]

	    fh = open (filename, 'r')
	    body = fh.read ()
	    fh.close ()

	    body = string.replace (body, '\n\n', '<P>\n\n')
	    td = td + [RawText (body)]
	    
	    return row
	    
	page = Page (linkBoxItem='NEWS')
	table = TableLite ()
	page.meat = page.meat + [table,]

	for file in items:
	    item = prepareNewsItem (file)
	    table.append (item)

	if filename == 'index.html':
	    p = Paragraph ()
	    p.append (Href ('oldnews.html', 'Older News'))
	    page.meat = page.meat + [p]

	page.write (filename)

    # Search all known news items, and sort them in reverse order
    list = glob.glob ('news/*')
    list.remove ('news/CVS')
    list.sort ()
    list.reverse ()
    
    # Create a main page with the Top 5 news items and another page
    # with the rest.
    genPage (list[:5], 'index.html')
    genPage (list[5:], 'oldnews.html')

def genStatus ():
    '''Create the status page. This page contains two images (jpg&png)
    with graphs of the sizes of repositories.'''

    # FIXME Read jobs.dat and create a table.
    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Size of AROS sources'))
    body.append (Paragraph (Image ('aros_size.png')))
    body.append (Paragraph (Href ('aros_size.jpg', 'Also as JPEG')))
    body.append (Heading (2, 'Size of contributed sources'))
    body.append (Paragraph (Image ('contrib_size.png')))
    body.append (Paragraph (Href ('contrib_size.jpg', 'Also as JPEG')))
    page.meat = page.meat + body
    page.write ('status.html')

    #from docs.src.credits import credits
    from credits import credits
    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Credits'))
    for area, names in credits:
	body.append (Heading (3, area))
	body.append (Paragraph (string.join (names, ', ')))
    page.meat = page.meat + body
    page.write ('credits.html')

def genDocumentation ():

    page = Page (linkBoxItem='Documentation')
    # Put the old docs here
    page.meat = page.meat + [Text ('FIXME')]
    page.write ('documentation.html')

class ThumbnailTable (TableLite):
    '''Helper class to create a table with thumbnails.'''

    def __init__ (self, *pics):
	if len (pics) == 1:
	    width = "40%"
	    itemwidth = 'width="40%"'
	else:
	    width = "80%"
	    itemwidth = 'width="40%"'

	TableLite.__init__ (self,
	    border="0",
	    width=width,
	    align="center",
	    bgcolor="#000066",
	    cellpadding=0,
	)
	row = TR ()
	self.append (row)
	td = TD ()
	row = row + [td]
	table2 = TableLite (
	    border="0",
	    bgcolor="#CCCCCC",
	    cellspacing="2",
	    cellpadding="5",
	)
	td = td + [table2]

	if (len (pics) & 1) == 1:
	    pics = list (pics) + [None]
	i, n = 0, len (pics)
	while i < n:
	    row = TR ()
	    left, right = pics[i], pics[i+1]
	    i = i + 2
	    left = left.toHtml ()
	    #print left[1]
	    left[1].attr_dict['width'] = itemwidth
	    #print dir (left[1])
	    #print left[1].attr_dict
	    if not right:
		if n == 2:
		    right = []
		else:
		    td = TD (colspan="2")
		    td = td + [RawText ('&nbsp;')]
		    right = [td]
	    else:
		right = right.toHtml ()
		right[1].attr_dict['width'] = itemwidth
	    row = row + left + right
	    
	    table2.append (row)

def genScreenshots ():
    '''Create a page with screenshots.'''

    page = Page (linkBoxItem='Screenshots')

    # First, the pictures of AROS developers, etc.
    page.meat = page.meat + [
	Name ('Pictures around AROS'),
	Heading (2, 'Pictures around AROS'),
	Paragraph ('If you ever wanted to know what Aaron "Optimizer" Digulla'
	    ' looks like, here are two pictures:'),
	ThumbnailTable (
	    Thumbnail ('pics/developers/Digulla-2.jpg'),
	    Thumbnail ('pics/developers/Digulla-1.jpg'),
	),
	Paragraph ('Picture of Nils Henrik Lorentzen:'),
	ThumbnailTable (
	    Thumbnail ('pics/developers/nlorentz.jpg'),
	),
	Paragraph ('Hopefully, more pictures of AROS developers will'
	    ' show up here :-)'),
	Name ('Screenshots'),
	Heading (2, 'Screenshots'),
    ]

    def processDir (dir):
	'''Read a directory and put all pictures in it into ThumbnailTables.
	The name of the directory must be YYYYMMDD.'''
	str = os.path.basename (dir)
	date = '%d.%d.%d' % (
	    int (str[6:8]),
	    int (str[4:6]),
	    int (str[0:4]),
	)
	fh = open (os.path.join (dir, 'README'), 'r')
	text = fh.read ()
	fh.close ()
	
	list = [
	    Paragraph (RawText ('%s - %s' % (date, text))),
	]
	files = glob.glob (os.path.join (dir, "*.*"))
	files.sort ()
	pics = []
	for file in files:
	    if file[-4:] == '.txt' or string.find (file, '_mini.') != -1:
		continue

	    pics.append (Thumbnail (os.path.join (screenshoturl, str,
		os.path.basename (file))))
	
	list.append (apply (ThumbnailTable, pics))
	return list
	    
    # Read all screenshots and sort them by date.
    dirs = glob.glob (os.path.join (htmldir, screenshoturl, '[0-9]*'))
    dirs.sort ()
    dirs.reverse ()
    for dir in dirs:
	page.meat = page.meat + processDir (dir)

    page.write ('screenshots.html')

def genDownload ():
    page = Page (linkBoxItem='Download')
    # Create the page for downloads
    page.meat = page.meat + [Text ('FIXME')]
    page.write ('download.html')

class FileInfo:
    '''Helper class which stores some useful information about a file,
    namely it's size (nicely formatted), the filename and the path
    to the file.
    
    self.filename - Name of the file (last element in the path)
    self.path - Full path to the file (might be relative)
    self.size - Nicely formatted size
    '''

    def __init__ (self, path):
	filename = os.path.basename (path)
	self.filename, self.path = filename, path

	size = os.path.getsize (path)

	if size > 1024:
	    size = ((size+1023) / 1024)
	    self.size = '%dKB' % size
	    if size > 1024:
		size = ((size+1023) / 1024)
		self.size = '%dMB' % size

class Snapshot (FileInfo):
    '''Helper class to store information about a snapshot. This is derived
    from the FileInfo class and contains this additional info:

    self.ext - Extension of the file
    self.date - Creation date (derived from the filename)
    self.title - Middle part of the filename
    self.log - FileInfo object about the logfile which belongs to
	    this snapshot or None.
    '''
    
    def __init__ (self, path):
	'''path must be a snapshot (Format:
	AROS-%(title)s-%(date)s.%(ext)s).'''
	FileInfo.__init__ (self, path)

	filename = self.filename
	self.ext = filename[-3:]
	filename = filename[:-4]
	self.date = filename[-8:]
	filename = filename[:-8]
	self.title = filename[5:-1]
	
	logfile = path[:-3] + 'log'
	if os.path.exists (logfile):
	    self.log = FileInfo (logfile)
	else:
	    self.log = None
	#print self.__dict__

class Thumbnail (FileInfo):
    '''Helper class for thumbnails. Pass it the name of a picture and
    it will contain FileInfo plus:

    self.width, self.height - Size of the picture
    self.format - Format of the file (GIF, JPEG, PNG, ...)
    self.thumbnailURL - URL of the thumbnail picture

    The thumbnail of the picture is created with ImageMagick if it
    doesn't exist or if it is outdated (the picture is newer).'''
    def __init__ (self, url):
	path = os.path.join (htmldir, url)
	FileInfo.__init__ (self, path)

	self.url = url
	pic = _Image.open (path)
	self.width, self.height = pic.size
	self.format = pic.format

	pos = string.rfind (url, '.')
	self.thumbnailURL = url[:pos] + '_mini.jpg'
	pos = string.rfind (path, '.')
	thumbnailPath = path[:pos] + '_mini.jpg'
	picMTime = os.path.getmtime (path)
	if os.path.exists (thumbnailPath):
	    tnMTime = os.path.getmtime (thumbnailPath)
	else:
	    tnMTime = 0
	if tnMTime < picMTime:
	    #tn = pic.convert ('RGB')
	    # Unfortunately, thumbnail() doesn't filter :-(
	    #tn.thumbnail = thumbnail
	    # FIXME event bicubic filtering looks pretty ugly.
	    # Replace this code with code that calls convert.
	    #thumbnail (tn, (64, 128))
	    #tn.save (thumbnailPath, 'JPEG')
	    if convert:
		os.system ('%s -geometry "64x128>" -quality 100 "%s" "%s"' % (
		    convert, path, thumbnailPath
		))

	infoFile = path[:pos] + '.txt'
	if os.path.exists (infoFile):
	    fh = open (infoFile)
	    self.text = fh.read ()
	    fh.close ()
	else:
	    self.text = ''

    def toHtml (self):
	'''Convert this into HTML code.'''
	return [
	    TD (
		Href (self.url, Image ((self.thumbnailURL, 0,0))),
		width="64",
		valign="TOP",
	    ),
	    TD (
		Paragraph (RawText (self.text)),
		Font (Text ('%s %dx%d (%s)' % (
		    self.format,
		    self.width, self.height,
		    self.size,
		)), size="-1"),
		#width="35%",
		valign="TOP",
	    ),
	]

def genSnapshots ():
    '''Create the page with the snapshots with sizes and links for
    download.'''
    page = Page (linkBoxItem='Download')

    files = glob.glob (os.path.join (ftpdir, 'snapshots/*.tgz'))
    if not files:
        page.meat = page.meat + [Text ('No snapshots found')]
    else:
	dict = {}
	columns = {}
	days = {}

	for file in files:
	    ss = Snapshot (file)
	    day = dict.get (ss.date, None)
	    if not day:
		day = {}
		dict[ss.date] = day
	    if ss.ext != 'tgz':
		print 'Unknown Snapshot', file
		continue

	    day[ss.title] = ss
	    columns[ss.title] = None
	    days[ss.date] = None
	
	table = TableLite (cellpadding=15, border=2)
	page.meat = page.meat + [table]
	
	colList = columns.keys ()
	colList.sort ()
	row = TR ()
	table.append (row)
	td = TH ('Date')
	row = row + [td]
	    
	for col in colList:
	    td = TH (col)
	    row = row + [td]
	
	dateList = days.keys ()
	dateList.sort ()
	dateList.reverse ()
	for date in dateList:
	    row = TR ()
	    table.append (row)

	    str = '%d.%d.%d' % (
		int (date[6:8]),
		int (date[4:6]),
		int (date[0:4]),
	    )
	    row = row + [TD (str)]

	    day = dict.get (date, {})

	    for col in colList:
		t = Text ()
		ss = day.get (col, None)
		if ss:
		    t.append (Href ('ftp://ftp.aros.org/pub/aros/snapshots/%s' % ss.filename,
			ss.size
		    ))
		else:
		    t.append ('-')
		
		if ss.log:
		    t.append ('(Log: ')
		    t.append (Href (
			'ftp://ftp.aros.org/pub/aros/snapshots/%s' % \
			    ss.log.filename,
			ss.log.size
		    ))
		    t.append (')')
		else:
		    if not ss.title in ('contrib', 'source'):
			t.append ('(No log)')

		row = row + [TD (t)]

    page.write ('snapshots.html')

def processLinks (links):
    list = List ()

    for link in links:
	if type (link) == type (()):
	    link, children = link[0], link[1:]
	else:
	    children = None

	text = Text (link.href)
	if link.text:
	    if type (link.text) == type (()):
		t = Text ()
		for item in link.text:
		    t.append (item)
	    else:
		t = Text (link.text)
	    text.append (t)
	if link.logo:
	    text.append (Image ((link.logo, 0,0)))

	list.append (text)
	
	if children:
	    sublist = processLinks (children)
	    list.append (sublist)
    
    return list

def genLinks ():
    '''Create a page with links from links.py.'''
    def processSection (links, title):
	body = []

	#print title, list

	body.append (Name (title))
	body.append (Heading (2, title))
	list = processLinks (links)
	body.append (list)

	return body

    page = Page (linkBoxItem='Links')

    from links import moreRelated, articles, homepages, lessRelated

    page.meat = page.meat \
	+ processSection (moreRelated, 'More Related') \
	+ processSection (articles, 'Articles') \
	+ processSection (homepages, 'Homepages') \
	+ processSection (lessRelated, 'Less Related')

    page.write ('links.html')

# Call all generators in turn
genNews ()
genStatus ()
genDocumentation ()
genScreenshots ()
genDownload ()
genSnapshots ()
genLinks ()
